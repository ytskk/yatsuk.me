{
  "frontmatter": {
    "title": "Finding unpaired number",
    "createdAt": "2022-05-22",
    "tags": [
      "Dart",
      "Algorithms"
    ],
    "description": "Analyzing the ways to search for a unique item in the list."
  },
  "content": "Imagine you have a list of elements where each of the have a pair, except one. For example:\n```dart\nconst numbers = [3, 8, 2, 3, 1, 2, 8];\n```\n\nIn this case we need to get 1, but how to achieve that?\n\n## Primitive way. Count frequencies of each number and select an element with 1 or odd value\nWe can use Map to store our elements where key is element and value is frequency.\n\n```dart\nint findUniqueNumberWithMap(List<int> numbers) {\n  Map<int, int> frequencies = {};\n\n  for (int number in numbers) {\n    frequencies[number] = (frequencies[number] ?? 0) + 1;\n  }\n\n  return frequencies.keys.firstWhere(\n    (number) => frequencies[number] == 1,\n    orElse: () => -1,\n  );\n}\n```\n\n### Props\n- It’s universal solution for almost any type and any frequency (even, odd, 1, 2 or any other number)\n\n### Cons\n- Requires Map, which is very expensive. \n- Needs to store additional collection\n\n### Complexity\nWell, in any case, we run through the whole list, there is nothing to win here. So the time complexity is O(N).\nWhat about memory usage? We need to maintain Map object that will have N / 2 - 1 keys (In the case of if all elements occur twice). Any way, it’s O(N)\n\nAs the result:\n\n| Time   | O(N) |\n|--------|------|\n| Memory | O(N) |\n\nLet’s improve this\n\n## Advanced way. Put elements to the Map is it’s not there and remove if already in.\nWe will slightly modify the previous version, sacrificing universality. We'll add an element to the Map if it doesn't exist before, and remove it if it already exists. In this case, after iteration, only one element will remain in the Map, which remains without a pair.\n\n```dart\nint findUniqueNumberWithMapAdvanced(List<int> numbers) {\n  Map<int, int> uniqueNumbers = {};\n\n  for (int number in numbers) {\n    if (uniqueNumbers.containsKey(number)) {\n      uniqueNumbers.remove(number);\n    } else {\n      uniqueNumbers[number] = 1;\n    }\n  }\n\n  return uniqueNumbers.keys.first;\n}\n```\n\n## Props\n- Stores less keys\n\n## Cons\n- Works only with 2, 1 frequency.\n- Memory consumption still depends on the original list.\n\nComplexity\nSame as previous one, but now we store N / 2 - 1 keys in the **worst** case, when only unique numbers came across. And then we will only remove elements.\n\nBetter but still\n\n| Time   | O(N) |\n|--------|------|\n| Memory | O(N) |\n\n## Best Practice\nThere is a another method to find a unique value from a list. We only need one additional number and that’s it!\n\n```dart\nint findUniqueNumberWithBitwise(List<int> numbers) {\n  int uniqueNumber = 0;\n\n  for (int number in numbers) {\n    uniqueNumber ^= number;\n  }\n\n  return uniqueNumber;\n}\n```\n\nWhat do we have now?\n\n| Time   | O(N) |\n|--------|------|\n| Memory | O(1) |\n\nExcellent solution \uD83E\uDD17\n\n## Bonus way\nA little practice. What is the complexity of this algorithm? How does indexOf work under the hood?\n\n```dart\nint findUniqueNumberWithLoop(List<int> numbers) {\n  for (int number in numbers) {\n    if (numbers.indexOf(number) == numbers.lastIndexOf(number)) {\n      return number;\n    }\n  }\n\n  return -1;\n}\n```\n\n\n\nGood luck \uD83D\uDC4B"
}